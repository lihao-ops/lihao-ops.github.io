程序员面试金典（第 6 版）
---

《程序员面试金典（第 6 版）》源自硅谷程序员的面试红宝书，层层紧扣程序员面试的每一个环节，全面而详尽地介绍了程序员应当如何应对面试，才能在面试中脱颖而出，为读者呈现了出自微软、苹果、谷歌等多家知名公司的百余道编程面试题。





>标识符含义

!!! 	书签

???    尚未搞懂

|||   可优化

***   重点题









#### [01.01. 判定字符是否唯一](https://leetcode-cn.com/problems/is-unique-lcci/)

难度简单196

实现一个算法，确定一个字符串 `s` 的所有字符是否全都不同。

**示例 1：**

```
输入: s = "leetcode"
输出: false 
```

**示例 2：**

```
输入: s = "abc"
输出: true
```

**限制：**

- `0 <= len(s) <= 100`
- 如果你不使用额外的数据结构，会很加分。

通过次数112,937

提交次数158,289



##### 方式一：Hashset特征去重

```java
/**
思路：
    使用set集合排除重复

 */
class Solution {
    public boolean isUnique(String astr) {
        //前置判断
        if(astr.length() == 1 || astr == null) return true;

        Set set = new HashSet();

        for(int i = 0;i < astr.length();i++){
            //判断此元素在集合中是否有包含,有就说明重复直接返回fasle
            if(set.contains(astr.charAt(i))) return false;

            set.add(astr.charAt(i));
        }
        return true;
    }
}
```

##### 方法二：全字符串boolean数组

```java
/**100 + 51.59
思路：
    1.定义二十六位全字符数组
    2.截取字符串中的每个字符s - 'a'对应到数组中
    3.如果出现数组被重复录入则返回false
 */
class Solution {
    public boolean isUnique(String astr) {
        //前置判断
        if(astr.length() == 0) return true;
        //校验数组
        boolean[] check = new boolean[26];
        for(int i = 0;i < astr.length();i++){
            char s = astr.charAt(i);
            //校验是否重复
            if(!check[s - 'a']){
                check[s - 'a'] = true;
            }else{
                return false;
            }
        }
        return true;
    }
}
```



















#### [01.02. 判定是否互为字符重排](https://leetcode-cn.com/problems/check-permutation-lcci/)

难度简单64

给定两个字符串 `s1` 和 `s2`，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。

**示例 1：**

```
输入: s1 = "abc", s2 = "bca"
输出: true 
```

**示例 2：**

```
输入: s1 = "abc", s2 = "bad"
输出: false
```

**说明：**

- `0 <= len(s1) <= 100`
- `0 <= len(s2) <= 100`

通过次数71,564

提交次数112,178

```java
/**100 + 21.33
思路：
    将两个字符串都转换为Char型数组,然后都进行排序,再转换为String类型对象进行对比
 */
class Solution {
    public boolean CheckPermutation(String s1, String s2) {
        //前置判断
        if(s1.length() != s2.length()) return false;

        char[] s11 = s1.toCharArray();
        char[] s22 = s2.toCharArray();
        Arrays.sort(s11);
        Arrays.sort(s22);
        return (new String(s11).equals(new String(s22)));
    }
}
```













#### [01.03. URL化](https://leetcode-cn.com/problems/string-to-url-lcci/)

难度简单64

URL化。编写一种方法，将字符串中的空格全部替换为`%20`。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用`Java`实现的话，请使用字符数组实现，以便直接在数组上操作。）

 

**示例 1：**

```
输入："Mr John Smith    ", 13
输出："Mr%20John%20Smith"
```

**示例 2：**

```
输入："               ", 5
输出："%20%20%20%20%20"
```

 

**提示：**

- 字符串长度在 [0, 500000] 范围内。

通过次数55,296

提交次数96,019

##### 方法一：利用StringBuilder

```java
/**30.95 + 85.24
思路：
    定义一个StringBuilder集合用于不断加入截取的字符元素
 */
class Solution {
    public String replaceSpaces(String S, int length) {

        //与实际不符就需要除去前后多出来的空格
        //实际上length表示就是字符串的前length位是有效，所以无需除去前后空格了。否则会出现中间有效的空格也会删除
        //比如5个有效位都是空格,但多出来一个空格，这样就会造成全部的空格都删除
        // if(S.length() != length) S = S.trim();

        StringBuilder sb = new StringBuilder();

        //遍历字符串中每一个字符,出现空格就替换为%20
        for(int i = 0;i < length;i++){
            if(S.charAt(i) == ' '){
                sb.append("%20");
                continue;
            }
            sb.append(S.charAt(i));
        }
        return sb.toString();
    }
}
```

##### 方法二：善用string方法

```java
/**80.97 + 68.49
思路：
    1.用substring截取出来字符串的有效长度
    2.用replace替换空格为%20
 */
class Solution {
    public String replaceSpaces(String S, int length) {
        return S.substring(0,length).replace(" ","%20");
    }
}
```





















#### [01.04. 回文排列](https://leetcode.cn/problems/palindrome-permutation-lcci/)

难度简单73

给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。

回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。

回文串不一定是字典当中的单词。

 

**示例1：**

```
输入："tactcoa"
输出：true（排列有"tacocat"、"atcocta"，等等）
```

 

通过次数49,356

提交次数90,704

```java
/**42.74 + 54.06
思路：
    1.利用set集合的不可重复性,将字符串s中的每一个字符不断加入到set集合中，
    2.如果遍历到当前的i号元素,set集合中此前也添加过一次,那么说明它们是一对,也就是无论如何都是符合题意的
      将它对应remove();
    3.最后如果还有一个元素说明s长度是奇数,剩下一个也是正常的,但是如果剩下两个就说明一定不符合题意,return false;
 */
class Solution {
    public boolean canPermutePalindrome(String s) {
        //前置判断
        if(s == null) return false;
        Set<Character> set = new HashSet();
        for(int i = 0;i < s.length();i++){
            if(set.contains(s.charAt(i))){
                set.remove(s.charAt(i));
            }//不是就加入
            else{
                set.add(s.charAt(i));
            }
        }
        return set.size() <= 1;
    }
}
```











#### [01.05. 一次编辑](https://leetcode-cn.com/problems/one-away-lcci/)

难度中等110

字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。

 

**示例 1:**

```
输入: 
first = "pale"
second = "ple"
输出: True
```

 

**示例 2:**

```
输入: 
first = "pales"
second = "pal"
输出: False
```

通过次数40,525

提交次数124,188

##### 分情况依次解决

```java
/**98.11 + 56.89
思路：
    分开三种情况来考虑
    1.加一个字符——两者长度不同,差值为1(左短右长)
    2.减一个字符——两者长度不同,差值为1(左长右短)
    3.替换一个字符——两者长度相同,但仅有一个字符不同
    实际上一1和2可以合并为一类，就是选择顺序可以调换一下
 */
class Solution {
        //校验方法,传入左短右长两字符——对比出来的当前字符不相同
        //则让长的字符指针单独向右移动一位
        boolean check(String x, String y){
            int n = 0,m = 0;
            while(n < x.length() && m < y.length()){
                //短的相同了再走
                //是为了准确记录到相同的字符个数再对比出最终结果
                if(x.charAt(n) == y.charAt(m)) n++;
                m++;    
            }
            return m - n <= 1;
        }    
    public boolean oneEditAway(String first, String second) {
        //利用长度指标来区分三种情况
        int n = first.length(),m = second.length();
        //1.左短右长
        if(m - n == 1){
            return check(first, second);
        }
        //2.左长右短
        else if(n - m == 1){
            return check(second, first);
        }
        //3.一个不同
        else if(n == m){
            boolean s = false;
            for(int i = 0,j = 0;i < n && j < m;i++,j++){
                //当前字符不相同
                if(first.charAt(i) != second.charAt(j)){
                    //进来第一次,可以,但第二次就直接返回false
                    if(!s){
                        s = true;
                        continue;
                    }
                    else{
                        return false;
                    }
                } 
            }    
            //最终只有一个不同则返回true;
            return true;    
        }//其余皆不符合题意
        else{
            return false;
        }
    }
}
```



##### 差值比较优化

```java
/**100 + 83.30
思路：
    差值比较:
    1.长度不同排除在长度上可以操作的可能区间c 属于 [1,-1]
 */
class Solution {
    public boolean oneEditAway(String first, String second) {
    
    //差值对比优化
    int len = first.length()-second.length();	
	
    //差值c > 1||len < -1排除了在长度上可以操作的可能区间 
    if (len > 1||len < -1) return false;
	
    int count = 1;

	for (int q = 0,h = 0; q < first.length() && h < second.length(); q++,h++) {
		if (first.charAt(q) != second.charAt(h)) {
                if (len == 1) { //second要不要添加一个字符
                    h--;
                }else if (len == -1) { //second要不要删除一个字符
                    q--;
                }	
                count--;
            }

            //最多编辑一次
            if (count < 0) return false;
	    }
	    return true;   
    }
}
```









#### [01.06. 字符串压缩](https://leetcode-cn.com/problems/compress-string-lcci/)

难度简单124

字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串`aabcccccaaa`会变为`a2b1c5a3`。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。

**示例1:**

```
 输入："aabcccccaaa"
 输出："a2b1c5a3"
```

**示例2:**

```
 输入："abbccd"
 输出："abbccd"
 解释："abbccd"压缩后为"a1b2c2d1"，比原字符串长度更长。
```

**提示：**

1. 字符串长度在[0, 50000]范围内。

通过次数84,664

提交次数180,703



##### 单指针计数

```java
/**44.39 + 47.10
思路：
    用循环从第二个字符串开始,判断与前一个字符串是否相等，如果都是相等就返回
 */
class Solution {
    public String compressString(String S) {
        //前置判断
        if(S.length() == 0 || S.length() == 1) return S;

        StringBuilder sb = new StringBuilder();
        //至少有一个
        int sum = 1;
        for(int i = 1;i < S.length();i++){
            if(S.charAt(i) == S.charAt(i-1)){
                sum += 1;
            }else{
                //刚好到不同了，就结算添加
                sb.append(S.charAt(i-1));
                sb.append(sum);
                //重置sum,重新统计新的字符
                sum = 1;
            }
        }
        /**注意：重点
        如果上述循环运行到了if(S.charAt(S.length()-1) == S.charAt(S.length()-2))也就是最后两个元素比较，会出现两种情况：
        1.重复，sum在++然后跳出循环此时并没了结算最后一个元素的情况
        2.不重复,两者不想等,此时到else执行,结算包含倒数第二个和它之前的元素了,也还是剩下最后一个元素没有结算,且它与上一个也就是倒数第二个元素不相等,到else中sum又被定义为1,所以也是符合期许的并不需要重新赋值
        
        */
        sb.append(S.charAt(S.length()-1));
        sb.append(sum);

        //求出来的压缩结果集长度都大于或者等于之前的长度，还不如不换
        return sb.length() >= S.length() ? S:sb.toString();
    }
}
```



##### 双指针

```java
/**41.2 + 95.89
思路：
    1.字符串解释说明
    2.利用双指针,左指针指向当前遍历相同子串的起始位置
    3.右指针不断遍历指向到当前相同子串最后的终止位置
    4.最后将S.charAt(n)拼接到sb中,并将m - n + 1结果集转换为字符串加入
    5.如果m + 1 < S.length() 则让n和m都指向m + 1然后重复操作
    6.return sb.toString();
 */
class Solution {
    public String compressString(String S) {
        //双指针
        int n = 0,m = 0;
        StringBuilder sb = new StringBuilder();
        while(n < S.length() && m < S.length()){
            //让m一直走到当前相同子串的终点位置
            while(m < S.length() && S.charAt(n) == S.charAt(m)) m++;
            //到此处时m刚好指向的是另一个相同子串的起始位置
            sb.append(S.charAt(n));
            sb.append(m - n);
            //再次重新校验新的子串
            n = m;            
        }
        //不小反大(或者相等)输出小
        return sb.length() >= S.length() ? S : sb.toString();
    }
}
```









#### [01.07. 旋转矩阵](https://leetcode-cn.com/problems/rotate-matrix-lcci/)

难度中等219

给你一幅由 `N × N` 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。

不占用额外内存空间能否做到？

 

**示例 1:**

```
给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

**示例 2:**

```
给定 matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

原地旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
```

**注意**：本题与主站 48 题相同：https://leetcode-cn.com/problems/rotate-image/

通过次数78,002

提交次数104,760

```java
/**100 + 40.89
思路：
    先将水平相对的行交换
    然后再将矩阵中对角的元素交换
 */
class Solution {
    public void rotate(int[][] matrix) {
        int len = matrix.length;
        //翻转水平行以长度的一般作为水平线
        for(int i = 0;i < len/2;i++){
            for(int j = 0;j < len;j++){
                int s = matrix[i][j];
                matrix[i][j] = matrix[len - i -1][j];
                matrix[len - i -1][j] = s;
            }
        }
        //对角两个值交换
        for (int i = 0; i < len; i++) {
            //行和列，对应的行和列形成对角,但是要以i作为对角线的中间线
            for (int j = 0; j < i; j++) {
                int s = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = s;
            }
        }
    }
}
```













#### [01.08. 零矩阵](https://leetcode.cn/problems/zero-matrix-lcci/)

难度中等52

编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。

 

**示例 1：**

```
输入：
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
输出：
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]
```

**示例 2：**

```
输入：
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
输出：
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]
```

通过次数55,484

提交次数89,270

```java
/**100 + 51.28
思路：
    1.用两个boolean数组来对应到matrix位置中的每一个位置
    2.初次遍历matrix,默认不是0则为false,为0对应到boolean数组置为true
    3.最后置换matrix只要判断当前列或者行存在元素为0就把当前位置置为0
 */
class Solution {
    public void setZeroes(int[][] matrix) {
        //用行和列两个数组来统计,其实就是因为：
        //如果此列中的第j个位置出现了0,那么这一列都要置为0;
        //依次类推,第j行也要全部置为0;也就是只要满足二者其一,无论对应行和对应列都要置为0;
        //行数组
        boolean[] row = new boolean[matrix[0].length];
        //列数组
        boolean[] column = new boolean[matrix.length];
        for(int i = 0;i < matrix.length;i++){
            for(int j = 0;j < matrix[0].length;j++){
                //对应行和列都置为true;
                if(matrix[i][j] == 0){
                    //行
                    row[j] = true;
                    //列
                    column[i] = true;                    
                }
            }
        }
        //只有对应row and column有一个为true当前位置都置为0
        for(int i = 0;i < matrix.length;i++){
            for(int j = 0;j < matrix[0].length;j++){
                if(row[j] || column[i]) matrix[i][j] = 0;
            }
        }
    }
}
```









#### [ 01.09. 字符串轮转](https://leetcode-cn.com/problems/string-rotation-lcci/)

难度简单106

字符串轮转。给定两个字符串`s1`和`s2`，请编写代码检查`s2`是否为`s1`旋转而成（比如，`waterbottle`是`erbottlewat`旋转后的字符串）。

**示例1:**

```
 输入：s1 = "waterbottle", s2 = "erbottlewat"
 输出：True
```

**示例2:**

```
 输入：s1 = "aa", s2 = "aba"
 输出：False
```



**提示：**

1. 字符串长度在[0, 100000]范围内。

**说明:**

1. 你能只调用一次检查子串的方法吗？

通过次数40,387

提交次数73,499

##### 方法一：字符串拼接

```java
/**5.03 + 8.20
思路：
    1.用两个字符串拼接，然后用另一个字符串
    2.遍历每次截取相同长度的子串比较，
    3.有相同的则返回true，否则false
*/
class Solution {
    public boolean isFlipedString(String s1, String s2) {
        //前置判断
        if(s1.length() != s2.length()) return false;
        String s = s2 + s2;
        int length = s1.length();
        for(int i = 0,j = length;j <= s.length();i++,j++){
            if(s.substring(i,j).equals(s1)) return true;            
         }
        return false;
    }
}
```

##### 方法二：String内置.contains()

```java
/**100 + 51.28
思路：
    先判断长度是否相同，不相同返回false，其次拼接两个s2，则如果是由s1旋转而成，则拼接后的s一定包含s1.
 */
class Solution {
    public boolean isFlipedString(String s1, String s2) {
        if(s1.length() != s2.length()) return false;
        String s = s2 + s2;
        //当且仅当此字符串包含指定的 char 值序列时才返回 true(源码注释)
        return s.contains(s1);
    }
}
```





#### [02.01. 移除重复节点](https://leetcode-cn.com/problems/remove-duplicate-node-lcci/)

难度简单143

编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。

**示例1:**

```
 输入：[1, 2, 3, 3, 2, 1]
 输出：[1, 2, 3]
```

**示例2:**

```
 输入：[1, 1, 1, 1, 2]
 输出：[1, 2]
```

**提示：**

1. 链表长度在[0, 20000]范围内。
2. 链表元素在[0, 20000]范围内。

**进阶：**

如果不得使用临时缓冲区，该怎么解决？

通过次数72,516

提交次数107,480



```java
/** 5.11 + 97.80
思路：
    遍历出节点的每一个节点，从它这个节点的之后的所有节点对比,判断是否重复
    类似二维数组遍历判断。
双指针：
    1.左指针用于遍历每个节点进行判断
    2.右指针由于判断是否重复,重复就跳过
    3.最终返回head
 */
class Solution {
    public ListNode removeDuplicateNodes(ListNode head) {
        //前置判断
        if(head == null) return head;
        ListNode s = head;

        while(s != null){
            //将链表的每个节点都与之后的所有节点进行对比,排除重复的情况
            ListNode node = s;

            //当前node节点的下一个节点不能为null防止越界
            while(node.next != null){
                if(node.next.val == s.val){
                    //当前节点的下一个节点就是重复需要删除的节点就将它的下一个节点指针直接指向下下个节点。
                    node.next = node.next.next;
                }else{
                    //不重复就++;
                    node = node.next;
                }
            }
            s = s.next;
        }
        return head;
    }
}
```











#### [02.02. 返回倒数第 k 个节点](https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/)

难度简单99

实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。

**注意：**本题相对原题稍作改动

**示例：**

```
输入： 1->2->3->4->5 和 k = 2
输出： 4
```

**说明：**

给定的 *k* 保证是有效的。

通过次数73,429

提交次数94,194

双指针解：

```java
/**100 + 49.97
双指针：
    1.让m先走k步
    2.同步行走,当m到达null节点
    3.当m到达终点返回n所在的链表节点值
 */
class Solution {
    public int kthToLast(ListNode head, int k) {
        //双指针
        ListNode n = head,m = head;
        for(int i = 0;i < k;i++) m = m.next;
        //到达null节点跳出
        while(m != null){
            n = n.next;
            m = m.next;
        }
        return n.val;
    }
}
```

















#### [02.03. 删除中间节点](https://leetcode-cn.com/problems/delete-middle-node-lcci/)

难度简单142

若链表中的某个节点，既不是链表头节点，也不是链表尾节点，则称其为该链表的「中间节点」。

假定已知链表的某一个中间节点，请实现一种算法，将该节点从链表中删除。

例如，传入节点 `c`（位于单向链表 `a->b->c->d->e->f` 中），将其删除后，剩余链表为 `a->b->d->e->f`

 

**示例：**

```
输入：节点 5 （位于单向链表 4->5->1->9 中）
输出：不返回任何数据，从链表中删除传入的节点 5，使链表变为 4->1->9
```

 

通过次数78,391

提交次数91,518

替换：

```java
/**100 + 6.93
双指针:
    首先要搞懂一点就是传入的参数node就是链表要删除的节点
 */
class Solution {
    public void deleteNode(ListNode node) {
        //1.将当前要删除的节点的节点值置为后面一个节点的节点值
        node.val = node.next.val;
        //将此时要删除的节点node的值转变为下一个需要的节点的值node.next.val
        //2.删除即可,也就是删除当前节点的后面一个结点，实现等价替换
        node.next = node.next.next;
    }
}
```















#### [02.04. 分割链表](https://leetcode-cn.com/problems/partition-list-lcci/)

难度中等88

给你一个链表的头节点 `head` 和一个特定值 `x` ，请你对链表进行分隔，使得所有 **小于** `x` 的节点都出现在 **大于或等于** `x` 的节点之前。

你不需要 **保留** 每个分区中各节点的初始相对位置。

 

**示例 1：**

![img](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203161534542.jpeg)

```
输入：head = [1,4,3,2,5,2], x = 3
输出：[1,2,2,4,3,5]
```

**示例 2：**

```
输入：head = [2,1], x = 2
输出：[1,2]
```

 

**提示：**

- 链表中节点的数目在范围 `[0, 200]` 内
- `-100 <= Node.val <= 100`
- `-200 <= x <= 200`

通过次数30,604

提交次数47,615



![img](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203161533458.png)



新建两条链表

```java
/**100 + 29
    对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前
    1.新建两条新链表h1,h2
    2.用 < x 来判断当前节点是否可以放入到h1
    3.用 >= x 来判断当前节点是否可以放入到h2
    4.拼接两条链表,将h1的尾节点连接到h2的头节点。
 */
class Solution {
    public ListNode partition(ListNode head, int x) {
        //创建两条链表,并建立对应指针
        ListNode q1 = new ListNode(0);
        ListNode q = q1;
        ListNode h2 = new ListNode(0);
        ListNode h = h2;
        
        //遍历链表head中的每一个元素参与判断
        while(head != null){
            //>= 放h链表
            if(head.val >= x){
                // ListNode node = new ListNode(head.val);
                //无需创建新节点,直接沿用head中的旧节点即可
                h.next = head;
                h = h.next;
            }//否则就放q链表中
            else{
                // ListNode node = new ListNode(head.val);
                q.next = head;
                q = q.next;
            }
            head = head.next;
        }
        //添加尾部空节点,并连接前后两条链表
        h.next = null;
        //注意：q到达q1的尾部节点,h2才是h2的头节点这样才能连接
        q.next = h2.next;
        return q1.next;
    }
}
```











#### [02.05. 链表求和](https://leetcode-cn.com/problems/sum-lists-lcci/)

难度中等116

给定两个用链表表示的整数，每个节点包含一个数位。

这些数位是反向存放的，也就是个位排在链表首部。

编写函数对这两个整数求和，并用链表形式返回结果。

 

**示例：**

```
输入：(7 -> 1 -> 6) + (5 -> 9 -> 2)，即617 + 295
输出：2 -> 1 -> 9，即912
```

**进阶：**思考一下，假设这些数位是正向存放的，又该如何解决呢?

**示例：**

```
输入：(6 -> 1 -> 7) + (2 -> 9 -> 5)，即617 + 295
输出：9 -> 1 -> 2，即912
```

通过次数44,547

提交次数95,690

```java
/**97.57 + 97.21
思路：
    获取两个链表中的相对的节点的值相加,成为新的节点的值
    用一个变量s用于定义表示相对两节点之间的和是否大于10(需要进一位),如果大于10就置当前两个节点的值为个位，
    s = true转移到下一位求解,最后判断如果每一位都需要进位就构件新的链表节点来成为最后一位
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode news = new ListNode(-1);
        ListNode newss = news;
        int num = -1;
        boolean q = false;
        //其中一个遍历完就要跳出来
        while(l1 != null && l2 != null){
            num = l1.val + l2.val;
            //说明上次需要进位
            if(q){
                 num += 1;
                q = false;
            }
            if(num > 9){
                q = true;
                num -= 10;
            }
            //创建新的节点添加进来
            newss.next = new ListNode(num);
            //循环条件
            newss = newss.next;
            l1 = l1.next;
            l2 = l2.next;
        }
        //两条链表不等长,其中有链表并未结束,先判断是否需要进位,无需进位则将该位置衔接
        while(l1 != null){
            num = l1.val;   
            //需要进位的情况
            if(q){
                //还是不需要进位那就加,需要就先不加
                if(num + 1 < 10){
                num += 1;
                q = false;
                }
                //注意：这里哪怕+1需要进1位也需要有相应的处理才行
                else{
                    num += 1;
                    num -= 10;
                }
            }
                newss.next = new ListNode(num); 
                newss = newss.next;
            	l1 = l1.next;
        }
        while(l2 != null){
            num = l2.val;
            //需要进位的情况
            if(q){
                //还是不需要进位那就加,需要就先不加
                if(num + 1 <= 9){
                num += 1;
                q = false;
                }
                //注意：这里哪怕+1需要进1位也需要有相应的处理才行
                else{
                    num += 1;
                    num -= 10;
                }
            }    
            newss.next = new ListNode(num); 
            newss = newss.next; 
            l2 = l2.next;
        }
        //这里如果还是true说明全部都需要进位
        if(q) newss.next = new ListNode(1);
        return news.next;
    }
}
```









#### [02.06. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list-lcci/)

难度简单100

编写一个函数，检查输入的链表是否是回文的。

 

**示例 1：**

```
输入： 1->2
输出： false 
```

**示例 2：**

```
输入： 1->2->2->1
输出： true 
```

 

**进阶：**
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？

通过次数46,967

提交次数96,769

```java
/**7.49 49.75
思路：
    将链表的值全部存入到list集合中,然后利用双指针比对
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head == null || head.next == null) return true;

        //装入所有节点的值
        List<Integer> list = new ArrayList();
        while(head != null){
            list.add(head.val);
            head = head.next;
        }

        //双指针
        int q = 0,h = list.size()-1;
        while(q < h){
            //[-129,-129]超过int类型的范围之后用==对比的就不是值了，而是对比内存地址了
            //所以用equals进行对比比较两者之间的值
            if(!list.get(q).equals(list.get(h))) return false;
            q++;
            h--;
        }
        return true;
    }
}
```













#### [02.07. 链表相交](https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/)

难度简单165

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交**：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

 

**示例 1：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```

**示例 2：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png)

```
输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at '2'
解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```

**示例 3：**

[![img](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203161832256.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png)

```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。
```

 

**提示：**

- `listA` 中节点数目为 `m`
- `listB` 中节点数目为 `n`
- `0 <= m, n <= 3 * 104`
- `1 <= Node.val <= 105`
- `0 <= skipA <= m`
- `0 <= skipB <= n`
- 如果 `listA` 和 `listB` 没有交点，`intersectVal` 为 `0`
- 如果 `listA` 和 `listB` 有交点，`intersectVal == listA[skipA + 1] == listB[skipB + 1]`

 

**进阶：**你能否设计一个时间复杂度 `O(n)` 、仅用 `O(1)` 内存的解决方案？

通过次数75,603

提交次数111,994

```java
/**100 + 86.59
思路：
 用两个指针q,h分别指向两个链表，如果存在相交节点:
 1、那么指针q遍历完A链表后，再从B链表开始遍历
 2、h遍历完B链表后，再从A链表开始遍历一定会在相交的节点处相遇
 3、如果没有相交节点，则一定会在null处相遇。所以最终只要返回q==h时的节点即可。
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode q = headA, h = headB;  
        while(q != h){
            q = q == null ? headB : q.next;
            h = h == null ? headA : h.next;
        }
        return q;
    }
}
```























#### [02.08. 环路检测](https://leetcode-cn.com/problems/linked-list-cycle-lcci/)

难度中等95

给定一个链表，如果它是有环链表，实现一个算法返回环路的`开头节点`。若环不存在，请返回 `null`。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：tail connects to node index 1
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**

![img](https://notes-1307435281.cos.ap-shanghai.myqcloud.com/note/master/202203161833184.png)

```
输入：head = [1,2], pos = 0
输出：tail connects to node index 0
解释：链表中有一个环，其尾部连接到第一个节点。
```

**示例 3：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

```
输入：head = [1], pos = -1
输出：no cycle
解释：链表中没有环。
```

 

**进阶：**

- 你是否可以不用额外空间解决此题？

 

通过次数32,700

提交次数60,751

```java
/**
双指针：
    q在head上,h也在head:
    1.刚开始让q每次走一步,然后,h每次走两步
    2.当q = h的时候,跳出循环
    3.然后q和h每次都只走一步,直到q 再次= h,这个点就是链表head的入环节点

    上述过程中,如果有一次出现了null那就输出null    
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if(head == null) return null;

        ListNode q = head,h = head;
        //q走1,h走2
        while(q != h){
            if(q == null || h.next == null) return null;
            q = q.next;
            h = h.next.next;
        }
        
        //跳出来了就让多走的h再次指回原点
        h = head;
        while(q != h){
            q = q.next;
            h = h.next;
        }

        return h;
    }
}
```











#### [03.01. 三合一](https://leetcode.cn/problems/three-in-one-lcci/)

难度简单52

三合一。描述如何只用一个数组来实现三个栈。

你应该实现`push(stackNum, value)`、`pop(stackNum)`、`isEmpty(stackNum)`、`peek(stackNum)`方法。`stackNum`表示栈下标，`value`表示压入的值。

构造函数会传入一个`stackSize`参数，代表每个栈的大小。

**示例1:**

```
 输入：
["TripleInOne", "push", "push", "pop", "pop", "pop", "isEmpty"]
[[1], [0, 1], [0, 2], [0], [0], [0], [0]]
 输出：
[null, null, null, 1, -1, -1, true]
说明：当栈为空时`pop, peek`返回-1，当栈满时`push`不压入元素。
```

**示例2:**

```
 输入：
["TripleInOne", "push", "push", "push", "pop", "pop", "pop", "peek"]
[[2], [0, 1], [0, 2], [0, 3], [0], [0], [0], [0]]
 输出：
[null, null, null, null, 2, 1, -1, -1]
```

 

**提示：**

- `0 <= stackNum <= 2`

通过次数17,231

提交次数32,319



##### 数组三指针

```java
/**100 + 45.23
栈空间分配(错位分配)：
    一:0, 0 + 3, 3 + 3 ... stackSize - 3
    二:1, 1 + 3, 4 + 3 ... stackSize - 2
    三:2, 2 + 3, 5 + 3 ... stackSize - 1
 */
class TripleInOne {
    int[] arr;
    int stackSize;
    int cur_num = 0;
    //记录3个栈每个栈可以插入的下标，本质上使用3个指针,这里直接简化使用一个大小为 3 的数组
    int[] indexs;

    public TripleInOne(int stackSize) {
        //3合1数组默认大小
        arr = new int[stackSize * 3];
        //当前全局size等于当前的大小
        this.stackSize = stackSize;
        indexs = new int[]{0,1,2};
    }
    //stackNum：表3个栈中某个选择某个栈的下标
    public void push(int stackNum, int value) {
        //当前栈的可插入下标超过了界限，那么表示已经满了，无法加入
        if(indexs[stackNum] >= stackSize * 3) return;
        //没有=或超出则加入
        arr[indexs[stackNum]] = value;
        indexs[stackNum] += 3;
    }
    
    public int pop(int stackNum) {
        //为空自然没有元素pop出
        if(isEmpty(stackNum)) return -1;
        //否则吐出3合1数组的3个元素
        indexs[stackNum] -= 3;
        return arr[indexs[stackNum]];
    }
    
    public int peek(int stackNum) {
        //为空则无元素展示出
        if(isEmpty(stackNum)) return -1;
        //当前栈的可插入下标 < 3,即为0,1,2时:表未有元素入栈
        return arr[indexs[stackNum] - 3];
    }
    
    public boolean isEmpty(int stackNum) {
        //当前栈的可插入下标 < 3，即为 0、1、2 时，表示还没有元素入栈，即为空
        return indexs[stackNum] < 3;
    }
}
```







#### [03.02. 栈的最小值](https://leetcode.cn/problems/min-stack-lcci/)

难度简单78

请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。



**示例：**

```
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```



通过次数34,322

提交次数55,557



##### 辅助栈

```java
/**98.91 + 34.20
辅助栈：
    定义两个栈空间,一个maxStack用于不断装入所有的元素,一个minStack装入不越来越小的元素
    1.第一次,minStack就先加入Integer.MAX_VALUE再去比较小的再添加
    2.而maxStack要一直加入元素的。
    3.top就是max主栈中的栈顶元素,而getmin自然就是minStack的栈顶元素了
 */
class MinStack {
    //这里用Deque双端队列也可以的
    Stack<Integer> maxStack;
    Stack<Integer> minStack;

    /** initialize your data structure here. */
    public MinStack() {
        
        //new LinkedList();也可以
        minStack = new Stack();
        maxStack = new Stack();

        //先放一个最大的再去不断取最小
        minStack.push(Integer.MAX_VALUE);
    }
    
    //maxStack一直加,小栈只加越来越小的
    public void push(int x) {
        maxStack.push(x);
        minStack.push(Math.min(minStack.peek(), x));
    }
    
    public void pop() {
        maxStack.pop();
        minStack.pop();
    }
    
    public int top() {
        return maxStack.peek();
    }
    
    //返回minStack的栈顶元素
    public int getMin() {
        return minStack.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```





#### [03.03. 堆盘子](https://leetcode.cn/problems/stack-of-plates-lcci/)

难度中等48

堆盘子。设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构`SetOfStacks`，模拟这种行为。`SetOfStacks`应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，`SetOfStacks.push()`和`SetOfStacks.pop()`应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）。 进阶：实现一个`popAt(int index)`方法，根据指定的子栈，执行pop操作。

当某个栈为空时，应当删除该栈。当栈中没有元素或不存在该栈时，`pop`，`popAt` 应返回 -1.

**示例1:**

```
 输入：
["StackOfPlates", "push", "push", "popAt", "pop", "pop"]
[[1], [1], [2], [1], [], []]
 输出：
[null, null, null, 2, 1, -1]
```

**示例2:**

```
 输入：
["StackOfPlates", "push", "push", "push", "popAt", "popAt", "popAt"]
[[2], [1], [2], [3], [0], [0], [0]]
 输出：
[null, null, null, null, 2, 1, 3]
```

通过次数13,331

提交次数34,525

> List<Stack<Integer>>

```java
/**64.62 + 42.42
思路：
    1.当前一个栈满了之后就会新建另一个栈,也就是定义一个可自由扩展的多个栈空间
    2.用List<Stack<Integer>> stacks实现
    3.
 */
class StackOfPlates {
    //全局变量
    List<Stack<Integer>> stacks = new ArrayList<>();
    int cap;

    public StackOfPlates(int cap) {
        this.cap = cap;
    }

    public void push(int val) {
        if (cap == 0) return;
        //当当前栈空了,就新增新的栈
        if (stacks.isEmpty()) stacks.add(new Stack<>());
        if (stacks.get(stacks.size() - 1).size() == cap) stacks.add(new Stack<>());
        stacks.get(stacks.size() - 1).push(val);
    }

    public int pop() {
        return popAt(stacks.size() - 1);
    }

    public int popAt(int index) {
        //cap=0或者index越界return - 1
        if (cap == 0 || index < 0 || index >= stacks.size()) return -1;
        //获取当前index号栈取出的栈顶元素
        int pop = stacks.get(index).pop();
        //若当前index号栈空了就排除在List中
        if (stacks.get(index).empty()) stacks.remove(index);
        return pop;
    }
}
```









#### [03.04. 化栈为队](https://leetcode.cn/problems/implement-queue-using-stacks-lcci/)

难度简单61

实现一个MyQueue类，该类用两个栈来实现一个队列。



**示例：**

```
MyQueue queue = new MyQueue();

queue.push(1);
queue.push(2);
queue.peek();  // 返回 1
queue.pop();   // 返回 1
queue.empty(); // 返回 false
```





**说明：**

- 你只能使用标准的栈操作 -- 也就是只有 `push to top`, `peek/pop from top`, `size` 和 `is empty` 操作是合法的。
- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
- 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。



通过次数31,054

提交次数43,275

```java
/**
思路：
    同一段序列，分别存入一个栈和一个队列，那么出栈序列T和出队序列S顺序刚好是相反的。
    那么如果用两个栈空间,将元素先存入stackRead,再将stackRead中的吐出的元素不断加入到stackWrite
    这个时候，再从stackWrite中吐出读取的顺序，刚好就是上述出队序列S。
    注意：
        在peek()方法中,当StackRead中没有元素了,就说明需要从其它写栈中去重新获取数据了
        就相当于排除顺序问题不看：写栈在最下读栈在上,这样才是一个完整的队列,所以,并不会出现
        1.如果StackRead中有数据，那么就直接弹出StackRead的栈顶元素；
        2.如果StackRead为空，先考虑把StackWrite中的元素压入StackRead，再弹出StackRead的栈顶元素。

 */
class MyQueue {
    Stack<Integer> stackWrite;
    Stack<Integer> stackRead;
    /** Initialize your data structure here. */
    public MyQueue() {
        stackWrite = new Stack();
        stackRead = new Stack();
    }
    
    /** Push element x to the back of queue. */
    public void push(int x) {
        //负责写入的栈,一直写进
        stackWrite.push(x);
    }
    
    /** Removes the element from in front of queue and returns that element. */
    public int pop() {
        //这个时候先要将stackWrite中的所有元素不断吐出加入到stackRead中
        peek();
        return stackRead.pop();
    }
    
    /** Get the front element. */
    public int peek() {
        /**
            为什么此时都没有更新stackRead,万一stackWrite中还有元素,此时并没有更新stackRead了
            这个时候结果怎么会保持正确？
            【先进先出】也就是说先入队列的就先出,所以这个不实时更新才能保证它出栈的顺序。
        */    
        if(!stackRead.isEmpty()) return stackRead.peek();
        
        //stackWrite所有元素吐出加入到stackRead
        while(!stackWrite.isEmpty()){
            stackRead.push(stackWrite.pop());
        }

        return stackRead.peek();
    }
    
    /** Returns whether the queue is empty. */
    public boolean empty() {
        return stackWrite.isEmpty() && stackRead.isEmpty();
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
```





#### [03.05. 栈排序](https://leetcode.cn/problems/sort-of-stacks-lcci/)

难度中等79

栈排序。 编写程序，对栈进行排序使最小元素位于栈顶。最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。该栈支持如下操作：`push`、`pop`、`peek` 和 `isEmpty`。当栈为空时，`peek` 返回 -1。

**示例1:**

```
 输入：
["SortedStack", "push", "push", "peek", "pop", "peek"]
[[], [1], [2], [], [], []]
 输出：
[null,null,null,1,null,2]
```

**示例2:**

```
 输入： 
["SortedStack", "pop", "pop", "push", "pop", "isEmpty"]
[[], [], [], [1], [], []]
 输出：
[null,null,null,null,null,true]
```

**说明:**

1. 栈中的元素数目在[0, 5000]范围内。

通过次数23,362

提交次数43,285

```java
/**
这题和 232. Implement Queue using Stacks 还有 implements stack using Queues 以及 Min Stack。 
思考的切入角度都是一样的。 
具体地， 就是采用增量法:
    1.就比如这题。你假设你的主stack已经是满足sorted stack的性质了。 
    2.我们需要思考的就是当你来一个新的元素的时候,怎么借用辅助栈/队列,来维持这个性质。
    3.对于这个题目,就是你需要将比它大的元素先放到辅助栈中,然后把目标值存入主栈中
    4.然后再把辅助栈的元素放回来。可以用同样的增量法的哲学做一下 232。
 */
class SortedStack {
        int[] heap;
        int index;

        public SortedStack() {
            heap = new int[5000];
            index = 0;
        }

        //heapInsert
        public void push(int val) {
            int i = index;
            heap[index++] = val;
            while (heap[i] < heap[(i - 1) / 2]) {
                swap(i, (i - 1) >> 1);
                i = (i - 1) >> 1;
            }
        }

        //heapify
        public void pop() {
            if (index != 0) {
                swap(0, --index);
                int i = 0;
                while ((i << 1) + 1 < index) {
                    if ((i << 1) + 2 < index) {
                        int min = Math.min(heap[(i << 1) + 1], heap[(i << 1) + 2]);
                        int x = heap[(i << 1) + 1] == min ? (i << 1) + 1 : (i << 1) + 2;
                        if (min < heap[i]) {
                            swap(i, x);
                            i = x;
                        } else {
                            break;
                        }
                    } else {
                        if (heap[i] > heap[(i << 1) + 1]) {
                            swap(i, (i << 1) + 1);
                            i = (i << 1) + 1;
                        } else {
                            break;
                        }
                    }
                }
            }
        }

        public int peek() {
            return index == 0 ? -1 : heap[0];
        }

        public boolean isEmpty() {
            return index == 0;
        }

        public void swap(int i, int j) {
            int temp = heap[i];
            heap[i] = heap[j];
            heap[j] = temp;
        }

    }
```







#### [03.06. 动物收容所](https://leetcode.cn/problems/animal-shelter-lcci/)

难度简单46

动物收容所。有家动物收容所只收容狗与猫，且严格遵守“先进先出”的原则。在收养该收容所的动物时，收养人只能收养所有动物中“最老”（由其进入收容所的时间长短而定）的动物，或者可以挑选猫或狗（同时必须收养此类动物中“最老”的）。换言之，收养人不能自由挑选想收养的对象。请创建适用于这个系统的数据结构，实现各种操作方法，比如`enqueue`、`dequeueAny`、`dequeueDog`和`dequeueCat`。允许使用Java内置的LinkedList数据结构。

`enqueue`方法有一个`animal`参数，`animal[0]`代表动物编号，`animal[1]`代表动物种类，其中 0 代表猫，1 代表狗。

`dequeue*`方法返回一个列表`[动物编号, 动物种类]`，若没有可以收养的动物，则返回`[-1,-1]`。

**示例1:**

```
 输入：
["AnimalShelf", "enqueue", "enqueue", "dequeueCat", "dequeueDog", "dequeueAny"]
[[], [[0, 0]], [[1, 0]], [], [], []]
 输出：
[null,null,null,[0,0],[-1,-1],[1,0]]
```

**示例2:**

```
 输入：
["AnimalShelf", "enqueue", "enqueue", "enqueue", "dequeueDog", "dequeueCat", "dequeueAny"]
[[], [[0, 0]], [[1, 0]], [[2, 1]], [], [], []]
 输出：
[null,null,null,null,[2,1],[0,0],[1,0]]
```

**说明:**

1. 收纳所的最大容量为20000

通过次数16,611

提交次数28,387

```java
/**85.32 +　99.26
思路：
    1.只能收养动物园中最老的(先进先出),使用LinkedList来实现
    2.或者可以挑选猫或狗(必须收养此类动物中最老的!)
    3.其中0 = 猫,1 = 狗
 */
class AnimalShelf {
    //动物园
    Deque<int[]> cat;
    Deque<int[]> dog;
    public AnimalShelf() {
        cat = new ArrayDeque<>();
        dog = new ArrayDeque<>();
    }
    /**
    0=猫,1=狗
     */
    public void enqueue(int[] animal) {
        if(animal[1] == 0) cat.add(animal);
        else dog.add(animal);
        
    }
    /**
    无论猫狗,选最老的：
        1.当cat和dog都是空返回空集
        2.当cat是空,返回dog中的poll()
        3.当dog是空,返回cat中的poll()
        4.cat的最老的猫没有dog中最老的狗老,就让cat
     */
    public int[] dequeueAny() {
        if(cat.isEmpty() && dog.isEmpty()) return new int[]{-1,-1};
        if(cat.isEmpty()) return dog.poll();
        if(dog.isEmpty()) return cat.poll();
        if(cat.peek()[0] < dog.peek()[0]) return cat.poll();
        return dog.poll();
    }
    //要狗：选最老的狗
    public int[] dequeueDog() {
        if(dog.isEmpty()) return new int[]{-1,-1}; 
        return dog.poll();
    }
    //要猫：选最老的猫
    public int[] dequeueCat() {
        if(cat.isEmpty()) return new int[]{-1,-1};
        return cat.poll();
    }
}
```







#### [04.01. 节点间通路](https://leetcode.cn/problems/route-between-nodes-lcci/)

难度中等67

节点间通路。给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。

**示例1:**

```
 输入：n = 3, graph = [[0, 1], [0, 2], [1, 2], [1, 2]], start = 0, target = 2
 输出：true
```

**示例2:**

```
 输入：n = 5, graph = [[0, 1], [0, 2], [0, 4], [0, 4], [0, 1], [1, 3], [1, 4], [1, 3], [2, 3], [3, 4]], start = 0, target = 4
 输出 true
```

**提示：**

1. 节点数量n在[0, 1e5]范围内。
2. 节点编号大于等于 0 小于 n。
3. 图中可能存在自环和平行边。

通过次数26,977

提交次数50,198

```java
/**测试用例只过一半！
思路：
    1.有向图两点间是否存在一条路线,存在就满足
    2.采用临接矩阵法：描绘一张图
    3.遍历数组将值以临接矩阵数组方式存入
    4.如果不通则为默认值false，否则为true
    4.输入
    0:1,2
    1:0,2
    2:0,1
 */
class Solution {
    public boolean findWhetherExistsPath(int n, int[][] graph, int start, int target) {
        //创建矩阵数组(false为不通)
        boolean[][] result = new boolean[n][n];

        //遍历二维数组取值装入到矩阵数组中
        for(int i = 0;i < graph.length;i++){
            //graph[i][0]为起点,graph[i][1]为终点
            result[graph[i][0]][graph[i][1]] = true; 
        }
        return result[start][target] || result[target][start]; 
    }
}
```

##### 回溯











#### [10.01. 合并排序的数组](https://leetcode-cn.com/problems/sorted-merge-lcci/)

难度简单135

给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。

初始化 A 和 B 的元素数量分别为 *m* 和 *n*。

**示例:**

```
输入:
A = [1,2,3,0,0,0], m = 3
B = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
```

**说明:**

- `A.length == n + m`

通过次数64,403

提交次数115,269

|||

```java
/**18.2 + 13.04
思路：
    1.将B放入到A的后面替换0
    2.Arrays.sort()排序
 */
class Solution {
    public void merge(int[] A, int m, int[] B, int n) {
        for(int i = 0;i < B.length;i++){
            A[i + m] = B[i];
        }
        Arrays.sort(A);
    }
}
```







